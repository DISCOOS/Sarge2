<link rel="import" href="../../lib/polymer/polymer.html">
<dom-module id="sarge-map">
    <style>
        #overlay {background-color: #c1f5f4; padding: 5px; border: 1px solid black; border-radius: 5px; text-align: right}
    </style>
    <template>
        <div id="cMap" style="width: 100%; height: 100%; position: fixed"></div>
        <div id="overlay"></div>
    </template>

    <script src="../../script/proj4.js"></script>
    <script src="../../script/ol.js"></script>
    <script src="../../script/utm.js"></script>

    <script>
        (function () {



            Polymer({
                is: 'sarge-map',
                properties: {
                    map: {
                        type: Object
                    },
                    radiusR25: Number,
                    radiusR50: Number,
                    ipp: {
                        type: Object
                    },
                    mapLocation: {
                        type: Object,
                        //observer: '_mapLocationChanged'
                    },
                    radiusR25Feature: Object,
                    radiusR50Feature: Object,
                    paperFeature: Object,
                    crossHairFeature: Object
                },
                attached: function () {
                    this.createMap();

                    window.setInterval(function (pMap) {
                        pMap.drawPaper();
                        pMap.drawCrossHair();
                        pMap.drawRadius();
                    }, 300, this);

                },
                createMap: function () {

                    for (var i = 1; i < 60; i++)
                    {
                        var zone = "EPSG:326" + (i < 10 ? "0" : "") + i.toString();
                        proj4.defs(zone, "+proj=utm +zone=" + i + " +ellps=WGS84 +datum=WGS84 +units=m +no_defs");
                    }
                    /*
                    proj4.defs("EPSG:32632", "+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs");
                    proj4.defs("EPSG:32633", "+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs");
                    */
                    
                    var sProjection = 'EPSG:32633';
                    var extent = {
                        'EPSG:32633': [-2500000, 3500000, 3045984, 9045984]
                    };

                    var projection = new ol.proj.Projection({
                        code: sProjection,
                        extent: extent[sProjection]
                    });

                    ol.proj.addProjection(projection);

                    ol.proj.addProjection(new ol.proj.Projection({
                        code: 'EPSG:4326',
                        extent: [-180,-90,180,90]
                    }));

                    var view = new ol.View({
                        projection: projection,
                        center: this.mapLocation ? [this.mapLocation.easting, this.mapLocation.northing] : [300000, 6550000],
                        zoom: 5
                    });
                    var vLayerGroup = new ol.layer.Group({
                        layers: [
                            this.createMapTile({ name: 'topo2' })
                        ]
                    })
                    this.map = new ol.Map({
                        target: 'cMap',
                        view: view
                    });

                    var vComponent = this;
                    this.map.on('moveend', function () {
                        var vView = vComponent.map.getView();
                        var vCenter = vView.getCenter();
                        vComponent.fire('map-move', { zoom: vView.getZoom(), location: { easting: vCenter[0], northing: vCenter[1] } });
                    });
                 
                    this.map.setLayerGroup(vLayerGroup);

                    var overlay = new ol.Overlay({
                        element: document.getElementById('overlay'),
                        positioning: 'bottom-center'
                    });

                    this.map.addControl(new ol.control.Zoom({
                        className: 'custom-zoom'
                    }));
                    var vMap = this;
                    this.map.on('click', function (event) {
                        // extract the spatial coordinate of the click event in map projection units
                        var coord = event.coordinate;
                        // transform it to decimal degrees
                        var degrees = ol.proj.transform(coord, 'EPSG:32633', 'EPSG:4326');
                        var zone = getUtmZone(degrees[0], degrees[1]);
                        var utmLocal = ol.proj.transform(coord, 'EPSG:32633', getProjectionName(zone));
                        // update the overlay element's content
                        var element = overlay.getElement();
                        element.innerHTML = vMap.formatDegrees(degrees) + "<br/>" + vMap.formatUtm32(zone, utmLocal);
                        // position the element (using the coordinate in the map's projection)
                        overlay.setPosition(coord);
                        // and add it to the map
                        vMap.map.addOverlay(overlay);
                    });
                },
                formatDegrees: function(pLocation)
                {
                    var vEastDegrees = Math.floor(pLocation[0]);
                    var vEastDecimal = Math.round((pLocation[0] - vEastDegrees) * 6000) / 100;
                    var vNorthDegrees = Math.floor(pLocation[1]);
                    var vNorthDecimal = Math.round((pLocation[1] - vNorthDegrees) * 6000) / 100;

                    return "<div style='text-align: right'>E " + vEastDegrees + "° " + vEastDecimal + "'<br/>N " + vNorthDegrees + "° " + vNorthDecimal + "'</div>";
                },
                formatUtm32: function(zone, location)
                {
                    var z = (zone < 10 ? "0" : "") + zone.toString();
                    return "<div style='text-align: right'>" + z + "V " + Math.round(location[0]) + "<br/>" + Math.round(location[1]) + "</div>";
                },
                getLocation: function () {
                    if (this.map) {
                        var vCenter = this.map.getView().getCenter();
                        if (vCenter)
                            return { zone: 33, easting: vCenter[0], northing: vCenter[1] };
                    }
                    else
                    {
                        return this.mapLocation;
                    }
                },
                setLocation: function (pLocation) {
                    if (!pLocation.zone)
                        pLocation.zone = 33;

                    if (this.map)
                        this.map.getView().setCenter([pLocation.easting, pLocation.northing]);
                    else
                        this.mapLocation = pLocation;
                },
                getZoom: function()
                {
                    if (this.map)
                        return this.map.getView().getZoom();
                },
                setZoom: function (pZoom) {
                    return this.map.getView().setZoom(pZoom);
                },
                ready: function ()
                {
                    
                },
                setMap: function(pMap)
                {
                    this.map.setLayerGroup(new ol.layer.Group({
                        layers: [
                            this.createMapTile(pMap),
                        ]
                    }));

                    // setting these to null will cause them to be recreated
                    this.radiusFeature = null;
                    this.radiusR50Feature = null;
                    this.crossHairFeature = null;
                    this.paperFeature = null;

                    if (this.map.layers)
                        this.map.layers[0].refresh({ force: true });
                },
                setScaleAndPaperSize: function(scale, paperSize)
                {
                    this.scale = scale;
                    this.paperSize = paperSize;
                    this.drawPaper();
                },
                createMapTile: function (pMap) {
                    if (pMap.name == "satelitt")
                        return this._tempMapTileForSatelitt();
                    else
                        return new ol.layer.Tile({
                            title: pMap.name,
                            source: new ol.source.TileWMS({
                                url: 'http://opencache.statkart.no/gatekeeper/gk/gk.open?',
                                params: {
                                    'LAYERS': pMap.name,
                                    'VERSION': '1.1.1',
                                    'FORMAT': 'image/png',
                                    'TILED': true
                                },
                                //tileGrid: tileGrid
                            })
                        });
                },
                _tempMapTileForSatelitt: function () {

                    var sProjection = 'EPSG:32633';
                    var extent = {
                        'EPSG:32633': [-2500000, 3500000, 3045984, 9045984]
                    };

                    var projection = new ol.proj.Projection({
                        code: sProjection,
                        extent: extent[sProjection]
                    });

                    var size = ol.extent.getWidth(projection.getExtent()) / 256;
                    var resolutions = new Array(20);
                    var matrixIds = new Array(20);
                    for (var z = 0; z < 20; ++z) {
                        // generate resolutions and matrixIds arrays for this WMTS
                        resolutions[z] = size / Math.pow(2, z);
                        matrixIds[z] = z;
                    }

                    return new ol.layer.Tile({
                        title: 'satelitt',
                        source: new ol.source.WMTS({
                            url: 'http://gatekeeper1.geonorge.no/BaatGatekeeper/gk/gk.nib_utm33_wmts_v2?gkt=3A609DF56BE96823E50C7273AC687DFEE8E95C46898458778DF829231A08590ADB1584C7A1E10204A7002ACA2E9D21402F15CFFEDCBD29AA8D018F0853CD0DA1',
                            layer: 'Nibcache_UTM33_EUREF89',
                            matrixSet: 'default028mm',
                            format: 'image/png',
                            projection: projection,
                            tileGrid: new ol.tilegrid.WMTS({
                                origin: ol.extent.getTopLeft(projection.getExtent()),
                                resolutions: resolutions,
                                matrixIds: matrixIds
                            }),
                            style: 'default',
                            wrapX: true
                        })
                    })
                },
                resetIpp: function()
                {
                    this.ipp = null;
                },
                setIpp: function(position)
                {
                    if (position)
                        this.ipp = position;
                    else
                        this.ipp = this.map.getView().getCenter();
                },
                getIpp: function()
                {
                    if (this.ipp)
                        return this.ipp;
                    else
                        return this.map.getView().getCenter();
                },
                drawRadius: function () {
                    var vCenter = this.getIpp();

                    if (this.radiusR25 || this.radiusR50) {

                        var vFeatures = [];

                        if (this.radiusR25)
                            vFeatures.push(new ol.Feature({
                                geometry: new ol.geom.Circle(vCenter, this.radiusR25)
                            }));
                        if (this.radiusR50)
                            vFeatures.push(new ol.Feature({
                                geometry: new ol.geom.Circle(vCenter, this.radiusR50)
                            })); 
                        
                        if (!this.radiusFeature)
                        {
                            var lineStyle = new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: '#3399ff',
                                    width: 2
                                })
                            });

                            var layerRadius = new ol.layer.Vector({
                                name: 'radius',
                                style: lineStyle,
                                source: new ol.source.Vector({
                                    features: vFeatures
                                }),
                                updateWhileInteracting: true,
                                updateWhileAnimating: true,
                                renderBuffer: 200
                            });

                            this.map.addLayer(layerRadius);
                            this.radiusFeature = layerRadius;
                        }
                        else
                        {
                            this.radiusFeature.setSource(new ol.source.Vector({
                                features: vFeatures
                            }));
                        }
                        
                    }
                },
                drawCrossHair: function ()
                {
                    var vCenter = this.getIpp();

                    var vSize = (this.paperSize && this.scale) ? (this.paperSize.width * this.scale.scale) / 4.0 : 10000;
                    var vOpening = 10 * Math.pow((25 - this.getZoom()) / 10, 3);

                    var vLines = [];

                    vLines.push([ // North
                        [vCenter[0], vCenter[1] + vSize],
                        [vCenter[0], vCenter[1] + vOpening]
                    ]);
                    vLines.push([ // South
                        [vCenter[0], vCenter[1] - vSize],
                        [vCenter[0], vCenter[1] - vOpening]
                    ]);
                    vLines.push([ // West
                        [vCenter[0] - vSize, vCenter[1]],
                        [vCenter[0] - vOpening, vCenter[1]]
                    ]);
                    vLines.push([ // East
                        [vCenter[0] + vSize, vCenter[1]],
                        [vCenter[0] + vOpening, vCenter[1]]
                    ]);

                    var vFeatures = [];
                    for (var i = 0; i < vLines.length; i++)
                    {
                        var vline = new ol.geom.LineString(vLines[i]);
                        var vFeature = new ol.Feature({ geometry: vline });
                        vFeatures.push(vFeature);
                    }

                    var lineStyle = new ol.style.Style({
                        stroke: new ol.style.Stroke({
                            color: '#999999',
                            width: 2
                        })
                    });
                    var vSource = new ol.source.Vector({
                        features: vFeatures
                    });

                    if (!this.crossHairFeature)
                    {
                        var layerLines = new ol.layer.Vector({
                            name: 'crossHair',
                            style: lineStyle,
                            source: vSource,
                            updateWhileInteracting: true,
                            updateWhileAnimating: true,
                            renderBuffer: 200
                        });
                        this.map.addLayer(layerLines);
                        this.crossHairFeature = layerLines;
                    }
                    else
                    {
                        this.crossHairFeature.setSource(vSource);
                    }
                },
                drawPaper: function()
                {
                    if (!this.paperSize || !this.scale)
                        return;

                    var vCenter = this.getIpp();
                    var vHalfWidth = this.paperSize.width * this.scale.scale / 2.0;
                    var vHalfHeight = this.paperSize.height * this.scale.scale / 2.0;

                    var polyCoords = [
                            [vCenter[0] - vHalfWidth, vCenter[1] + vHalfHeight],
                            [vCenter[0] + vHalfWidth, vCenter[1] + vHalfHeight],
                            [vCenter[0] + vHalfWidth, vCenter[1] - vHalfHeight],
                            [vCenter[0] - vHalfWidth, vCenter[1] - vHalfHeight]
                    ];

                    if (!this.paperFeature)
                    {
                        var feature = new ol.Feature({
                            geometry: new ol.geom.Polygon([polyCoords])
                        });

                        var layer = new ol.layer.Vector({
                            source: new ol.source.Vector({
                                features: [feature],
                            }),
                            style: new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: '#00cc00',
                                    width: 4
                                })
                            }),
                            updateWhileInteracting: true,
                            updateWhileAnimating: true
                        });

                        this.map.addLayer(layer);
                        this.paperFeature = feature;
                    }
                    else
                    {
                        this.paperFeature.setGeometry(new ol.geom.Polygon([polyCoords]));
                    }
                }
            });
        })();
    </script>
</dom-module>
